### This file was generated by Nexus Schema
### Do not make changes to this file directly


input AccountInput {
  password: String!
  server: String!
  username: String!
}

type AccountSettings {
  allowTasks: Boolean!
  autoBuild: Boolean!
  autoParty: Boolean!
  autoStart: Boolean!
  autoUnits: Boolean!
  tasksCoolDown: CoolDown!
}

enum AdventureCriteria {
  Closest
  Furthest
  Random
}

type AutoAdventureSettings {
  adventureCriteria: AdventureCriteria!
  allow: Boolean!
  coolDown: CoolDown!
  hardMinHealth: Int!
  maxTravelTime: Duration!
  normalMinHealth: Int!
  preferHard: Boolean!
}

type AutoBuildLogEntryContent {
  fieldId: Int!
  level: Int!
  name: String!
  type: Int!
}

type AutoBuildSettings {
  allow: Boolean!
  autoCropFields: Boolean!
  autoStorage: AutoStorageSettings!
  coolDown: CoolDown!
  dualQueue: DualQueueSettings!
  minCrop: Int!
  useHeroResources: Boolean!
}

type AutoMentorSettings {
  acceptDailyRewards: Boolean!
  acceptTaskRewards: Boolean!
  completeTasks: CompleteTasksSettings!
}

type AutoPartySettings {
  allowLarge: Boolean!
  allowSmall: Boolean!
  coolDown: CoolDown!
  minCulturePointsLarge: Int!
  minCulturePointsSmall: Int!
  useHeroResources: Boolean!
}

type AutoStorageOptionSettings {
  allow: Boolean!
  overflowLevel: Int!
}

type AutoStorageSettings {
  allowFreeSpots: Boolean!
  granary: AutoStorageOptionSettings!
  warehouse: AutoStorageOptionSettings!
}

type AutoUnitsBuildingSettings {
  allow: Boolean!
  maxBuildTime: Duration!
  units: [AutoUnitsUnitSettings!]!
}

type AutoUnitsLogEntryContent {
  amount: Int!
  index: Int!
  tribe: Tribe!
  unitName: String!
}

type AutoUnitsSettings {
  allow: Boolean!
  barracks: AutoUnitsBuildingSettings!
  coolDown: CoolDown!
  minCrop: Int!
  residence: AutoUnitsBuildingSettings!
  stable: AutoUnitsBuildingSettings!
  useHeroResources: Boolean!
  workshop: AutoUnitsBuildingSettings!
}

type AutoUnitsUnitSettings {
  autoBuild: Boolean!
  index: Int!
  targetAmount: Int!
  trainForever: Boolean!
}

input AvailableNewBuildingsInput {
  fieldId: Int!
  villageId: ID!
}

enum BotState {
  None
  Paused
  Pending
  Running
  Stopping
}

type BuildingInProgress {
  fieldId: Int!
  finishedAt: Timestamp!
  level: Int!
  type: Int!
}

type BuildingInfo {
  maxLevel: Int!
  name: String!
}

type BuildingLevelInfo {
  cost: Resources!
}

type BuildingQueue {
  buildingRanges: [QueuedBuildingRange!]!
  infrastructureBuildingTime: Duration!
  resourcesBuildingTime: Duration!
  totalBuildingTime: Duration!
  totalCost: Resources!
}

type BuildingSpot {
  fieldId: Int!
  id: ID!
  level: BuildingSpotLevel!
  type: Int!
}

type BuildingSpotLevel {
  actual: Int!
  ongoing: Int
  queued: Int
  total: Int!
}

type BuildingSpots {
  infrastructure: [BuildingSpot!]!
  resources: ResourceFields!
}

enum ClaimHeroResourcesReason {
  AutoBuild
  AutoParty
  AutoUnits
}

input ClearQueueInput {
  villageId: ID!
}

type CompleteTasksSettings {
  allow: Boolean!
  allowedTaskIds: [String!]!
  taskIds: [String!]!
}

input CompleteTasksSettingsInput {
  allow: Boolean!
  allowedTaskIds: [String!]!
  taskIds: [String!]!
}

type CoolDown {
  max: Duration!
  min: Duration!
}

input CoolDownInput {
  max: DurationInput!
  min: DurationInput!
}

type Coords {
  x: Int!
  y: Int!
}

input DequeueBuildingAtFieldInput {
  fieldId: Int!
  targetLevel: Int
  villageId: ID!
}

input DequeueBuildingInput {
  queueId: ID!
  villageId: ID!
}

enum DualQueuePreference {
  Infrastructure
  Resources
}

type DualQueueSettings {
  allow: Boolean!
  preference: DualQueuePreference!
}

input DualQueueSettingsInput {
  allow: Boolean!
  preference: DualQueuePreference!
}

type Duration {
  days: Int!
  hours: Int!
  minutes: Int!
  seconds: Int!
}

input DurationInput {
  days: Int!
  hours: Int!
  minutes: Int!
  seconds: Int!
}

input EnqueueBuildingInput {
  fieldId: Int!
  targetLevel: Int
  type: Int!
  villageId: ID!
}

type GameInfo {
  tribe: Tribe!
}

type GeneralSettings {
  chromePath: String!
  headlessChrome: Boolean!
}

type GeneralVillageSettings {
  allowTasks: Boolean!
}

type HeroInformation {
  health: Int!
  state: HeroState!
  village: Village
}

type HeroLevelUpItem {
  defBonus: Int!
  id: ID!
  name: String!
  offBonus: Int!
  offensiveStrength: Int!
  resources: Int!
}

input HeroLevelUpItemInput {
  defBonus: Int!
  name: String!
  offBonus: Int!
  offensiveStrength: Int!
  resources: Int!
}

type HeroLevelUpSettings {
  levelUpItems: [HeroLevelUpItem!]!
}

enum HeroState {
  Dead
  InVillage
  OnAdventure
  Reviving
  Unknown
}

type LogEntry {
  content: LogEntryContent!
  id: ID!
  timestamp: Timestamp!
  village: Village
}

union LogEntryContent = AutoBuildLogEntryContent | AutoUnitsLogEntryContent | ResourceClaimLogEntryContent | TextLogEntryContent

enum MapSearchState {
  None
  Scanning
  Searching
}

type Mutation {
  addHeroLevelUpItem(item: HeroLevelUpItemInput!): HeroLevelUpItem!
  clearQueue(villageId: ID!): Boolean
  createAccount(account: AccountInput!): UserAccount!
  deleteAccount(id: ID!): UserAccount!
  dequeueBuilding(input: DequeueBuildingInput!): Boolean
  dequeueBuildingAtField(input: DequeueBuildingAtFieldInput!): Boolean
  dequeueBuildingsBlock(bottomBuildingQueueId: ID!, topBuildingQueueId: ID!, villageId: ID!): Boolean
  enqueueBuilding(input: EnqueueBuildingInput!): Boolean
  exportAccountSettings(accountId: ID!, path: String!): Boolean
  exportAccounts(path: String!): Boolean
  exportGeneralSettings(path: String!): Boolean
  importAccountSettings(accountId: ID!, path: String!): Boolean
  importAccounts(path: String!): Boolean
  importGeneralSettings(path: String!): Boolean
  moveQueuedBuildingAsHighAsPossible(queueId: ID!, villageId: ID!): Boolean
  moveQueuedBuildingToIndex(index: Int!, queueId: ID!, villageId: ID!): Boolean
  moveQueuedBuildingsBlockAsHighAsPossible(bottomBuildingQueueId: ID!, topBuildingQueueId: ID!, villageId: ID!): Boolean
  moveQueuedBuildingsBlockToIndex(bottomBuildingQueueId: ID!, index: Int!, topBuildingQueueId: ID!, villageId: ID!): Boolean
  refreshVillage(villageId: ID!): Boolean
  removeHeroLevelUpItem(id: ID!): HeroLevelUpItem!
  resetAccountSettings: AccountSettings!
  resetAutoAdventureSettings: AutoAdventureSettings!
  resetAutoBuildSettings(villageId: ID!): AutoBuildSettings!
  resetAutoMentorSettings: AutoMentorSettings!
  resetAutoPartySettings(villageId: ID!): AutoPartySettings!
  resetAutoUnitsSettings(villageId: ID!): AutoUnitsSettings!
  resetGeneralSettings: GeneralSettings!
  resetGeneralVillageSettings(villageId: ID!): GeneralVillageSettings!
  resetNextTaskExecution(task: TaskType!): Timestamp!
  resetNextTasksExecution: Timestamp!
  resetNextVillageTaskExecution(task: TaskType!, villageId: ID!): Timestamp!
  scanWholeMap: Boolean
  searchMap(input: SearchMapInput!): Boolean
  setNextTaskExecution(delay: DurationInput!, task: TaskType!): Timestamp!
  setNextTasksExecution(delay: DurationInput!): Timestamp!
  setNextVillageTaskExecution(delay: DurationInput!, task: TaskType!, villageId: ID!): Timestamp!
  signIn(accountId: ID!): Boolean
  signOut: Boolean
  startBot: Boolean
  stopBot: Boolean
  stopMapScan: Boolean
  updateAccount(account: AccountInput!, id: ID!): UserAccount!
  updateAccountSettings(settings: UpdateAccountSettingsInput!): AccountSettings!
  updateAutoAdventureSettings(settings: UpdateAutoAdventureSettingsInput!): AutoAdventureSettings!
  updateAutoBuildSettings(settings: UpdateAutoBuildSettingsInput!, villageId: ID!): AutoBuildSettings!
  updateAutoMentorSettings(settings: UpdateAutoMentorSettingsInput!): AutoMentorSettings!
  updateAutoPartySettings(settings: UpdateAutoPartySettingsInput!, villageId: ID!): AutoPartySettings!
  updateAutoUnitsBuildingSettings(buildingType: Int!, settings: UpdateAutoUnitsBuildingSettingsInput!, villageId: ID!): AutoUnitsSettings!
  updateAutoUnitsSettings(settings: UpdateAutoUnitsSettingsInput!, villageId: ID!): AutoUnitsSettings!
  updateAutoUnitsUnitSettings(settings: UpdateAutoUnitsUnitSettingsInput!, villageId: ID!): AutoUnitsSettings!
  updateGeneralSettings(settings: UpdateGeneralSettingsInput!): GeneralSettings!
  updateGeneralVillageSettings(settings: UpdateGeneralVillageSettingsInput!, villageId: ID!): GeneralVillageSettings!
  updateHeroLevelUpItem(id: ID!, item: HeroLevelUpItemInput!): HeroLevelUpItem!
}

interface Node {
  id: ID!
}

type Query {
  account(id: ID!): UserAccount!
  accountSettings: AccountSettings!
  accounts: [UserAccount!]!
  activeVillageId: ID!
  autoAdventureSettings: AutoAdventureSettings!
  autoBuildSettings(villageId: ID!): AutoBuildSettings!
  autoMentorSettings: AutoMentorSettings!
  autoPartySettings(villageId: ID!): AutoPartySettings!
  autoUnitsSettings(villageId: ID!): AutoUnitsSettings!
  availableNewBuildingsTypes(input: AvailableNewBuildingsInput!): [Int!]!
  botState: BotState!
  buildingInfo(buildingType: Int!): BuildingInfo!
  buildingLevelInfo(buildingType: Int!, level: Int!): BuildingLevelInfo!
  buildingQueue(villageId: ID!): BuildingQueue!
  buildingSpots(villageId: ID!): BuildingSpots!
  buildingsInProgress(villageId: ID!): [BuildingInProgress!]!
  canMoveQueuedBuildingToIndex(index: Int!, queueId: ID!, villageId: ID!): Boolean!
  canMoveQueuedBuildingsBlockToIndex(bottomBuildingQueueId: ID!, index: Int!, topBuildingQueueId: ID!, villageId: ID!): Boolean!
  crannyCapacity(villageId: ID!): VillageCrannyCapacity!
  currentAccount: UserAccount!
  gameInfo: GameInfo!
  generalSettings: GeneralSettings!
  generalVillageSettings(villageId: ID!): GeneralVillageSettings!
  heroInformation: HeroInformation!
  heroLevelUpSettings: HeroLevelUpSettings!
  isAccountTaken(account: AccountInput!): Boolean!
  isBotActive: Boolean!
  lastSignedAccountId: String
  logEntries: [LogEntry!]!
  mapScanProgress: Float!
  mapSearchState: MapSearchState!
  nextTaskExecution(task: TaskType!): Timestamp!
  nextTasksExecution: Timestamp!
  nextVillageTaskExecution(task: TaskType!, villageId: ID!): Timestamp!
  unitInfo(index: Int!): UnitInfo!
  village(villageId: ID!): Village
  villageTileTypes: [String!]!
  villages: [Village!]!
}

type QueuedBuilding {
  buildingTime: Duration!
  fieldId: Int!
  level: Int!
  queueId: ID!
  queueIndex: Int!
  type: Int!
}

type QueuedBuildingRange {
  buildingTime: Duration!
  buildings: [QueuedBuilding!]!
  cost: Resources!
  fieldId: Int!
  id: String!
  type: Int!
}

type ResourceClaimLogEntryContent {
  reason: ClaimHeroResourcesReason!
  resources: Resources!
}

type ResourceFields {
  clay: [BuildingSpot!]!
  crop: [BuildingSpot!]!
  iron: [BuildingSpot!]!
  wood: [BuildingSpot!]!
}

type Resources {
  clay: Int!
  crop: Int!
  freeCrop: Int!
  iron: Int!
  total: Int!
  wood: Int!
}

input SearchMapInput {
  cropBonus: Int!
  origin: SearchMapOriginInput!
  types: [String!]!
}

input SearchMapOriginInput {
  radius: Int!
  x: Int!
  y: Int!
}

type Subscription {
  accountSettingsUpdated: AccountSettings!
  accountsUpdated: [UserAccount!]!
  activeVillageIdChanged: ID!
  autoAdventureSettingsUpdated: AutoAdventureSettings!
  autoMentorSettingsUpdated: AutoMentorSettings!
  autoUnitsSettingsUpdated(villageId: ID!): AutoUnitsSettings!
  botActivityChanged: Boolean!
  botStateChanged: BotState!
  buildingsInProgressUpdated(villageId: ID!): [BuildingInProgress!]!
  heroInformationUpdated: HeroInformation!
  heroLevelUpSettingsChanged: HeroLevelUpSettings!
  lastSignedAccountIdUpdated: String
  logEntryAdded: LogEntry!
  mapScanProgressUpdated: Float!
  mapSearchFinished: [VillageTile!]!
  mapSearchStateChanged: MapSearchState!
  nextTaskExecutionChanged(task: TaskType!): Timestamp!
  nextTasksExecutionChanged: Timestamp!
  nextVillageTaskExecutionChanged(task: TaskType!, villageId: ID!): Timestamp!
  onBuildingSpotUpdated(fieldId: Int!, villageId: ID!): BuildingSpot!
  onCrannyCapacityUpdated(villageId: ID!): VillageCrannyCapacity!
  queueUpdated(villageId: ID!): BuildingQueue!
  villageUpdated(villageId: ID!): Village!
  villagesUpdated: [Village!]!
}

enum TaskType {
  AutoAdventure
  AutoBuild
  AutoMentor
  AutoParty
  AutoUnits
}

type TextLogEntryContent {
  message: String!
  messageType: TextLogEntryType!
}

enum TextLogEntryType {
  Error
  Info
}

type Timestamp {
  totalSeconds: Int!
}

input TimestampInput {
  totalSeconds: Int!
}

enum Tribe {
  Egyptians
  Gauls
  Huns
  Natars
  Nature
  Romans
  Teutons
}

type UnitInfo {
  name: String!
}

input UpdateAccountSettingsInput {
  allowTasks: Boolean!
  autoBuild: Boolean!
  autoParty: Boolean!
  autoStart: Boolean!
  autoUnits: Boolean!
  tasksCoolDown: CoolDownInput!
}

input UpdateAutoAdventureSettingsInput {
  adventureCriteria: AdventureCriteria!
  allow: Boolean!
  coolDown: CoolDownInput!
  hardMinHealth: Int!
  maxTravelTime: DurationInput!
  normalMinHealth: Int!
  preferHard: Boolean!
}

input UpdateAutoBuildSettingsInput {
  allow: Boolean!
  autoCropFields: Boolean!
  autoStorage: UpdateAutoStorageSettingsInput!
  coolDown: CoolDownInput!
  dualQueue: DualQueueSettingsInput!
  minCrop: Int!
  useHeroResources: Boolean!
}

input UpdateAutoMentorSettingsInput {
  acceptDailyRewards: Boolean!
  acceptTaskRewards: Boolean!
  completeTasks: CompleteTasksSettingsInput!
}

input UpdateAutoPartySettingsInput {
  allowLarge: Boolean!
  allowSmall: Boolean!
  coolDown: CoolDownInput!
  minCulturePointsLarge: Int!
  minCulturePointsSmall: Int!
  useHeroResources: Boolean!
}

input UpdateAutoStorageOptionSettingsInput {
  allow: Boolean!
  overflowLevel: Int!
}

input UpdateAutoStorageSettingsInput {
  allowFreeSpots: Boolean!
  granary: UpdateAutoStorageOptionSettingsInput!
  warehouse: UpdateAutoStorageOptionSettingsInput!
}

input UpdateAutoUnitsBuildingSettingsInput {
  allow: Boolean!
  maxBuildTime: DurationInput!
}

input UpdateAutoUnitsSettingsInput {
  allow: Boolean!
  coolDown: CoolDownInput!
  minCrop: Int!
  useHeroResources: Boolean!
}

input UpdateAutoUnitsUnitSettingsInput {
  autoBuild: Boolean!
  index: Int!
  targetAmount: Int!
  trainForever: Boolean!
}

input UpdateGeneralSettingsInput {
  chromePath: String!
  headlessChrome: Boolean!
}

input UpdateGeneralVillageSettingsInput {
  allowTasks: Boolean!
}

type UserAccount implements Node {
  id: ID!
  password: String!
  server: String!
  username: String!
}

type Village {
  coords: Coords!
  id: ID!
  isCapital: Boolean!
  name: String!
  resources: VillageResources!
}

type VillageCapacity {
  granary: Int!
  warehouse: Int!
}

type VillageCrannyCapacity {
  actual: Int!
  ongoing: Int!
  total: Int!
}

type VillageResources {
  amount: Resources!
  capacity: VillageCapacity!
  production: Resources!
}

type VillageTile {
  claimed: Boolean
  coords: Coords!
  cropBonus: Int!
  distance: Float!
  type: String!
}
