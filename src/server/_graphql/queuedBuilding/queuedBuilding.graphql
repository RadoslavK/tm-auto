type QueuedBuilding {
    canMoveDown: Boolean!
    canMoveUp: Boolean!
    level: Int!
    name: String!
    type: Int!
    queueId: ID!
    cost: Cost!
    fieldId: Int!
}

type BuildingQueue {
    buildings: [QueuedBuilding!]!
    totalCost: Cost!
}

extend type Query {
    buildingQueue(villageId: Int!): BuildingQueue!
    canMoveBuildingToIndex(villageId: Int!, queueId: String!, index: Int!): Boolean!
}

input ClearQueueInput {
    villageId: Int!
}

input EnqueueBuildingInput {
    fieldId: Int!
    type: Int!
    villageId: Int!
    targetLevel: Int
}

extend type Mutation {
    clearQueue(villageId: Int!): Boolean!
    dequeueBuilding(input: QueuedBuildingManipulationInput!): Boolean!
    dequeueBuildingAtField(input: DequeueBuildingAtFieldInput!): Boolean!
    enqueueBuilding(input: EnqueueBuildingInput!): Boolean!
    moveQueuedBuildingAsHighAsPossible(villageId: Int!, queueId: ID!): Boolean!
}

input QueuedBuildingManipulationInput {
    queueId: ID!
    villageId: Int!
}

input DequeueBuildingAtFieldInput {
    deleteAll: Boolean!
    fieldId: Int!
    villageId: Int!
}

extend type Mutation {
    moveQueuedBuildingDown(input: QueuedBuildingManipulationInput!): Boolean!
    moveQueuedBuildingUp(input: QueuedBuildingManipulationInput!): Boolean!
    moveQueuedBuildingToIndex(villageId: Int!, queueId: String!, index: Int!): Boolean!
}

type Subscription {
    onQueueUpdated(villageId: Int!): BuildingQueue!
}
