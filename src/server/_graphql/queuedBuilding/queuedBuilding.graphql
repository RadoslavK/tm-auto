type QueuedBuilding {
    level: Int!
    type: Int!
    queueId: ID!
    queueIndex: Int!
    fieldId: Int!
}

type QueuedBuildingRange {
    id: String!
    buildings: [QueuedBuilding!]!
    type: Int!
    fieldId: Int!
    cost: Cost!
}

type BuildingQueue {
    buildingRanges: [QueuedBuildingRange!]!
    totalCost: Cost!
}

extend type Query {
    buildingQueue(villageId: ID!): BuildingQueue!
    canMoveQueuedBuildingToIndex(villageId: ID!, queueId: ID!, index: Int!): Boolean!
    canMoveQueuedBuildingsBlockToIndex(villageId: ID!, topBuildingQueueId: ID!, bottomBuildingQueueId: ID!, index: Int!): Boolean!
}

input ClearQueueInput {
    villageId: ID!
}

input EnqueueBuildingInput {
    fieldId: Int!
    type: Int!
    villageId: ID!
    targetLevel: Int
}


input DequeueBuildingInput {
    queueId: ID!
    villageId: ID!
}

input DequeueBuildingAtFieldInput {
    deleteAll: Boolean!
    fieldId: Int!
    villageId: ID!
}

extend type Mutation {
    clearQueue(villageId: ID!): Boolean
    dequeueBuilding(input: DequeueBuildingInput!): Boolean
    dequeueBuildingAtField(input: DequeueBuildingAtFieldInput!): Boolean
    enqueueBuilding(input: EnqueueBuildingInput!): Boolean
    moveQueuedBuildingToIndex(villageId: ID!, queueId: ID!, index: Int!): Boolean
    moveQueuedBuildingsBlockToIndex(villageId: ID!, topBuildingQueueId: ID!, bottomBuildingQueueId: ID!, index: Int!): Boolean
    moveQueuedBuildingAsHighAsPossible(villageId: ID!, queueId: ID!): Boolean
}

type Subscription {
    queueUpdated(villageId: ID!): BuildingQueue!
}
